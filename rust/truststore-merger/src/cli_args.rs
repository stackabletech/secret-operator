use std::{
    fs,
    io::Write,
    path::PathBuf,
    process::{Command, Stdio},
};

use anyhow::{Context, bail};
use clap::Parser;
use openssl::{pkcs12::Pkcs12, x509::X509};
use stackable_secret_operator_utils::pem::split_pem_certificates;

#[derive(Parser, Debug)]
#[command(version, about)]
pub struct Cli {
    /// The path to output the resulting pkcs12 to
    #[arg(long)]
    pub out: PathBuf,

    /// List of PEM certificate(s)
    #[arg(long = "pem")]
    pub pems: Vec<PathBuf>,

    /// List of PKCS12 certificate(s)
    #[arg(long = "pkcs12")]
    pub pkcs12s: Vec<PathBuf>,
}
impl Cli {
    pub fn certificate_sources(&self) -> Vec<CertInput> {
        let pems = self.pems.iter().cloned().map(CertInput::Pem);
        let pkcs12s = self.pkcs12s.iter().cloned().map(CertInput::Pkcs12);
        pems.chain(pkcs12s).collect()
    }
}

#[derive(Debug)]
pub enum CertInput {
    Pem(PathBuf),
    Pkcs12(PathBuf),
}

impl CertInput {
    pub fn read(&self) -> anyhow::Result<Vec<X509>> {
        let file_contents =
            fs::read(self.path()).with_context(|| format!("failed to read file from {self:?}"))?;

        match self {
            CertInput::Pem(_) => parse_pem_contents(&file_contents).with_context(|| {
                format!(
                    "failed to parse PEM contents from {path:?}",
                    path = self.path()
                )
            }),
            CertInput::Pkcs12(_) => {
                let password = ""; // TODO
                parse_pkcs12_file_workaround(&file_contents, password)
            }
        }
    }

    pub fn path(&self) -> &PathBuf {
        match self {
            CertInput::Pem(path) => path,
            CertInput::Pkcs12(path) => path,
        }
    }
}

fn parse_pem_contents(pem_bytes: &[u8]) -> anyhow::Result<Vec<X509>> {
    let pems = split_pem_certificates(pem_bytes);
    pems.into_iter()
        .map(|pem| X509::from_pem(pem).context("failed to parse PEM encoded certificate"))
        .collect()
}

/// This function is how we would *should* do it.
///
/// But with legacy old truststores generated by secret-operator (as of 2025-09), this fails with OpenSSL 3 because it
/// removed the old, legacy algorithms:
///
/// `error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:355:Global default library context, Algorithm (RC2-40-CBC : 0), Properties ()`
///
/// I tried this code to load the legacy provider:
///
/// ```ignore
/// const LEGACY_PROVIDER_NAME: &str = "legacy";
///
/// unsafe {
///     let provider_name =
///         std::ffi::CString::new(LEGACY_PROVIDER_NAME).expect("constant CString is always valid");
///     let provider = ffi::OSSL_PROVIDER_load(ptr::null_mut(), provider_name.as_ptr());
///     if provider.is_null() {
///         bail!("Failed to load OpenSSL provider {LEGACY_PROVIDER_NAME}");
///     }
/// }
/// ```
///
/// It helped a bit, but we got the next error:
///
/// `error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:375:Global default library context, Algorithm (PKCS12KDF : 0), Properties (<null>), error:1180006B:PKCS12 routines:pkcs12_gen_mac:key gen error:crypto/pkcs12/p12_mutl.c:267:, error:1180006D:PKCS12 routines:PKCS12_verify_mac:mac generation error:crypto/pkcs12/p12_mutl.c:331:, error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:375:Global default library context, Algorithm (PKCS12KDF : 0), Properties (<null>), error:1180006B:PKCS12 routines:pkcs12_gen_mac:key gen error:crypto/pkcs12/p12_mutl.c:267:, error:1180006D:PKCS12 routines:PKCS12_verify_mac:mac generation error:crypto/pkcs12/p12_mutl.c:331:, error:11800071:PKCS12 routines:PKCS12_parse:mac verify failure:crypto/pkcs12/p12_kiss.c:67:`
///
/// So I ditched that effort and we are now shelling out to the CLI. Sorry!
/// The proper solution would be that secret-operator writes pkcs12 truststores using modern algorithms.
#[allow(unused)]
fn parse_pkcs12_file(file_contents: &[u8], password: &str) -> anyhow::Result<Vec<X509>> {
    let parsed = Pkcs12::from_der(file_contents)
        .context("failed to parse PKCS12 DER encoded file")?
        .parse2(password)
        .context("Failed to parse PKCS12 using the provided password")?;

    parsed
        .ca
        .context("pkcs12 truststore did not contain a CA")?
        .into_iter()
        .map(Ok)
        .collect()
}

/// Workaround for [`parse_pkcs12_file`]. Please read it's documentation for details.
///
/// Yes, I hate it as well...
fn parse_pkcs12_file_workaround(file_contents: &[u8], password: &str) -> anyhow::Result<Vec<X509>> {
    let mut child = Command::new("openssl")
        .args(&[
            "pkcs12",
            "-nokeys",
            "-password",
            &format!("pass:{}", password),
            // That's the important part!!!
            "-legacy",
        ])
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .context("Failed to spawn openssl process")?;

    {
        let stdin = child
            .stdin
            .as_mut()
            .context("Failed to open openssl process stdin")?;
        stdin
            .write_all(file_contents)
            .context("Failed to write PKCS12 data to openssl process stdin")?;
    }

    let output = child
        .wait_with_output()
        .context("Failed to read openssl process output")?;
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("openssl process failed with STDERR: {stderr:?}");
    }

    parse_pem_contents(&output.stdout).with_context(|| {
        format!(
            "failed to parse openssl process output, which should be PEM. STDOUT: {stdout}?",
            stdout = String::from_utf8_lossy(&output.stdout)
        )
    })
}
