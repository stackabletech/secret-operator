use std::{
    io::Write,
    process::{Command, Stdio},
};

use openssl::{pkcs12::Pkcs12, x509::X509};
use snafu::{OptionExt, ResultExt, Snafu};

#[derive(Debug, Snafu)]
pub enum ParseError {
    #[snafu(display("failed to deseralize PKCS#12 DER encoded file"))]
    DeserializeFile { source: openssl::error::ErrorStack },

    #[snafu(display("failed to parse file as PKCS#12"))]
    ParseFile { source: openssl::error::ErrorStack },

    #[snafu(display("the PKCS#12 truststore contains no certificate authority"))]
    NoCertificateAuthority,
}

/// This function is how we would *should* do it.
///
/// But with legacy old truststores generated by secret-operator (as of 2025-09), this fails with OpenSSL 3 because it
/// removed the old, legacy algorithms:
///
/// `error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:355:Global default library context, Algorithm (RC2-40-CBC : 0), Properties ()`
///
/// I tried this code to load the legacy provider:
///
/// ```ignore
/// const LEGACY_PROVIDER_NAME: &str = "legacy";
///
/// unsafe {
///     let provider_name =
///         std::ffi::CString::new(LEGACY_PROVIDER_NAME).expect("constant CString is always valid");
///     let provider = ffi::OSSL_PROVIDER_load(ptr::null_mut(), provider_name.as_ptr());
///     if provider.is_null() {
///         bail!("Failed to load OpenSSL provider {LEGACY_PROVIDER_NAME}");
///     }
/// }
/// ```
///
/// It helped a bit, but we got the next error:
///
/// `error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:375:Global default library context, Algorithm (PKCS12KDF : 0), Properties (<null>), error:1180006B:PKCS12 routines:pkcs12_gen_mac:key gen error:crypto/pkcs12/p12_mutl.c:267:, error:1180006D:PKCS12 routines:PKCS12_verify_mac:mac generation error:crypto/pkcs12/p12_mutl.c:331:, error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:375:Global default library context, Algorithm (PKCS12KDF : 0), Properties (<null>), error:1180006B:PKCS12 routines:pkcs12_gen_mac:key gen error:crypto/pkcs12/p12_mutl.c:267:, error:1180006D:PKCS12 routines:PKCS12_verify_mac:mac generation error:crypto/pkcs12/p12_mutl.c:331:, error:11800071:PKCS12 routines:PKCS12_parse:mac verify failure:crypto/pkcs12/p12_kiss.c:67:`
///
/// So I ditched that effort and we are now shelling out to the CLI. Sorry!
/// The proper solution would be that secret-operator writes PKCS12 truststores using modern algorithms.
/// For that we probably(?) drop the p12 crate?
#[allow(unused)]
pub fn parse_file(file_contents: &[u8], password: &str) -> Result<Vec<X509>, ParseError> {
    let parsed = Pkcs12::from_der(file_contents)
        .context(DeserializeFileSnafu)?
        .parse2(password)
        .context(ParseFileSnafu)?;

    parsed
        .ca
        .context(NoCertificateAuthoritySnafu)?
        .into_iter()
        .map(Ok)
        .collect()
}

#[derive(Debug, Snafu)]
pub enum WorkaroundError {
    #[snafu(display("failed to spawn openssl process"))]
    SpawnProcess { source: std::io::Error },

    #[snafu(display("failed to acquire openssl process stdin handle"))]
    AcquireStdinHandle,

    #[snafu(display("failed to write data to openssl process stdin"))]
    WriteToStdin { source: std::io::Error },

    #[snafu(display("failed to wait for openssl process to complete"))]
    WaitForProcess { source: std::io::Error },

    #[snafu(display("the openssl process failed to complete successfully: {reason:?}"))]
    ProcessFailed { reason: String },

    #[snafu(display("failed to parse openssl process stdout as PEM"))]
    ParseOutput {
        source: crate::parsers::pem::ParseError,
    },
}

/// Workaround for [`parse_pkcs12_file`]. Please read it's documentation for details.
///
/// Yes, I hate it as well...
pub fn parse_file_workaround(
    file_contents: &[u8],
    password: &str,
) -> Result<Vec<X509>, WorkaroundError> {
    let mut child = Command::new("openssl")
        .args(&[
            "pkcs12",
            "-nokeys",
            "-password",
            &format!("pass:{password}"),
            // That's the important part!!!
            "-legacy",
        ])
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .context(SpawnProcessSnafu)?;

    {
        let stdin = child.stdin.as_mut().context(AcquireStdinHandleSnafu)?;
        stdin.write_all(file_contents).context(WriteToStdinSnafu)?;
    }

    let output = child.wait_with_output().context(WaitForProcessSnafu)?;
    output.status.success().context(|| ProcessFailedSnafu {
        reason: String::from_utf8_lossy(&output.stderr),
    })?;

    crate::parsers::pem::parse_contents(&output.stdout).context(ParseOutputSnafu)
}

trait BoolExt {
    fn context<F, C, E>(self, context: F) -> Result<(), E>
    where
        F: FnOnce() -> C,
        C: snafu::IntoError<E, Source = snafu::NoneError>,
        E: std::error::Error + snafu::ErrorCompat;
}

impl BoolExt for bool {
    fn context<F, C, E>(self, context: F) -> Result<(), E>
    where
        F: FnOnce() -> C,
        C: snafu::IntoError<E, Source = snafu::NoneError>,
        E: std::error::Error + snafu::ErrorCompat,
    {
        if self {
            Ok(())
        } else {
            Err(context().into_error(snafu::NoneError))
        }
    }
}
