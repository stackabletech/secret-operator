use std::{
    io::Write,
    process::{Command, Stdio},
};

use openssl::{pkcs12::Pkcs12, x509::X509};
use snafu::{OptionExt, ResultExt, whatever};
use stackable_secret_operator_utils::pem::split_pem_certificates;

pub fn parse_pem_contents(pem_bytes: &[u8]) -> Result<Vec<X509>, snafu::Whatever> {
    let pems = split_pem_certificates(pem_bytes);
    pems.into_iter()
        .map(|pem| X509::from_pem(pem).whatever_context("failed to parse PEM encoded certificate"))
        .collect()
}

/// This function is how we would *should* do it.
///
/// But with legacy old truststores generated by secret-operator (as of 2025-09), this fails with OpenSSL 3 because it
/// removed the old, legacy algorithms:
///
/// `error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:355:Global default library context, Algorithm (RC2-40-CBC : 0), Properties ()`
///
/// I tried this code to load the legacy provider:
///
/// ```ignore
/// const LEGACY_PROVIDER_NAME: &str = "legacy";
///
/// unsafe {
///     let provider_name =
///         std::ffi::CString::new(LEGACY_PROVIDER_NAME).expect("constant CString is always valid");
///     let provider = ffi::OSSL_PROVIDER_load(ptr::null_mut(), provider_name.as_ptr());
///     if provider.is_null() {
///         bail!("Failed to load OpenSSL provider {LEGACY_PROVIDER_NAME}");
///     }
/// }
/// ```
///
/// It helped a bit, but we got the next error:
///
/// `error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:375:Global default library context, Algorithm (PKCS12KDF : 0), Properties (<null>), error:1180006B:PKCS12 routines:pkcs12_gen_mac:key gen error:crypto/pkcs12/p12_mutl.c:267:, error:1180006D:PKCS12 routines:PKCS12_verify_mac:mac generation error:crypto/pkcs12/p12_mutl.c:331:, error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:crypto/evp/evp_fetch.c:375:Global default library context, Algorithm (PKCS12KDF : 0), Properties (<null>), error:1180006B:PKCS12 routines:pkcs12_gen_mac:key gen error:crypto/pkcs12/p12_mutl.c:267:, error:1180006D:PKCS12 routines:PKCS12_verify_mac:mac generation error:crypto/pkcs12/p12_mutl.c:331:, error:11800071:PKCS12 routines:PKCS12_parse:mac verify failure:crypto/pkcs12/p12_kiss.c:67:`
///
/// So I ditched that effort and we are now shelling out to the CLI. Sorry!
/// The proper solution would be that secret-operator writes PKCS12 truststores using modern algorithms.
/// For that we probably(?) drop the p12 crate?
#[allow(unused)]
pub fn parse_pkcs12_file(
    file_contents: &[u8],
    password: &str,
) -> Result<Vec<X509>, snafu::Whatever> {
    let parsed = Pkcs12::from_der(file_contents)
        .whatever_context("failed to parse PKCS12 DER encoded file")?
        .parse2(password)
        .whatever_context("Failed to parse PKCS12 using the provided password")?;

    parsed
        .ca
        .whatever_context("pkcs12 truststore did not contain a CA")?
        .into_iter()
        .map(Ok)
        .collect()
}

/// Workaround for [`parse_pkcs12_file`]. Please read it's documentation for details.
///
/// Yes, I hate it as well...
pub fn parse_pkcs12_file_workaround(
    file_contents: &[u8],
    password: &str,
) -> Result<Vec<X509>, snafu::Whatever> {
    let mut child = Command::new("openssl")
        .args(&[
            "pkcs12",
            "-nokeys",
            "-password",
            &format!("pass:{password}"),
            // That's the important part!!!
            "-legacy",
        ])
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .whatever_context("Failed to spawn openssl process")?;

    {
        let stdin = child
            .stdin
            .as_mut()
            .whatever_context("Failed to open openssl process stdin")?;
        stdin
            .write_all(file_contents)
            .whatever_context("Failed to write PKCS12 data to openssl process stdin")?;
    }

    let output = child
        .wait_with_output()
        .whatever_context("Failed to read openssl process output")?;
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        whatever!("openssl process failed with STDERR: {stderr:?}");
    }

    parse_pem_contents(&output.stdout).with_whatever_context(|_| {
        format!(
            "failed to parse openssl process output, which should be PEM. STDOUT: {stdout}?",
            stdout = String::from_utf8_lossy(&output.stdout)
        )
    })
}
